<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body class="w3-container">
    <div class="w3-container w3-bar w3-card-4 w3-cyan w3-margin-bottom">
        <h3 class="w3-bar-item" style="color: white;">Sato Lab. Robot Console</h3>
        <!-- <h3 id="battery_label" class="w3-bar-item w3-right">Battery: - %</h3> -->
    </div>

    <div class="w3-row">
        <div class="w3-col s2 m2 l2">
            <label for="rest_api">REST API :</label>
        </div>
        <div class="w3-col s5 m5 l5">
            <input id="rest_api" class="w3-input w3-border w3-padding-small" type="text" required
                value="http://<your ip>:8000/">
        </div>
    </div>
    <div class="w3-row">
        <div class="w3-col s2 m2 l2">
            <label for="rest_api">Scope : </label>
        </div>
        <div class="w3-col s5 m5 l5">
            <input id="scope_input" class="w3-input w3-border w3-padding-small w3-margin-right" type="text" required
                value="simu">
        </div>
    </div>
    <div class="w3-row">
        <div class="w3-col s2 m2 l2">
            <label for="rest_api">Drive Topic : </label>
        </div>
        <div class="w3-col s5 m5 l5">
            <input id="drive_topic_input" class="w3-input w3-border w3-padding-small w3-margin-right" type="text" required
                value="rt/cmd_vel">
        </div>
    </div>
    <!-- <div class="w3-row">
        <div class="w3-col s2 m2 l2">
            <label for="rest_api">LiDAR Topic : </label>
        </div>
        <div class="w3-col s5 m5 l5">
            <input id="lidar_topic_input" class="w3-input w3-border w3-padding-small w3-margin-right" type="text" required
                value="rt/scan">
        </div>
    </div> -->

    <br />

    <!-- If your robot has a camera and zcapture installed (from zenoh-demos/computer-vision/zcam/), uncomment this:  -->
    
    <div class="w3-row">
        <div class="w3-col s6 m6 l6">
            <div class="w3-card-4">
                <header class="w3-bar w3-cyan" onclick="document.getElementById('Camera1').classList.toggle('w3-hide');">
                    <h5 id="camera_label1" class="w3-bar-item" style="margin: 0; color: white;">Camera 1</h5>
                    <h5 class="w3-bar-item w3-right" style="margin: 0;"><i class='fa fa-video-camera' style='color: white;'></i></h5>
                </header>
                <div id="Camera1" class="w3-container w3-padding">
                    <div class="camera-image-container">
                        <img id="camera_img1" class="w3-container w3-padding" style="max-width: 95%; max-height: 300px;" src="" />
                    </div>
                </div>
            </div>
        </div>
        <div class="w3-col s6 m6 l6">
            <div class="w3-card-4" style="position: relative;">
                <header class="w3-bar w3-cyan" onclick="document.getElementById('Camera2').classList.toggle('w3-hide');">
                    <h5 id="camera_label2" class="w3-bar-item" style="margin: 0; color: white;">Camera 2</h5>
                    <h5 class="w3-bar-item w3-right" style="margin: 0;"><i class='fa fa-video-camera' style='color: white;'></i></h5>
                </header>
                <div id="Camera2" class="w3-container w3-padding">
                    <div class="camera-image-container">
                        <button onmousedown="startTwistRotation(0.0, 1.0)" onmouseup="stopTwistRotation()"
                         ontouchstart="startTwistRotation(0.0, 1.0);" ontouchend="stopTwistRotation();" class="cross-button left"><i class="fas fa-caret-left"></i></button>
                        <img id="camera_img2" class="w3-container w3-padding" style="max-width: 95%; max-height: 300px;" src="" />
                        <button onmousedown="startTwistRotation(0.0, -1.0)" onmouseup="stopTwistRotation()"
                        ontouchstart="startTwistRotation(0.0, -1.0);" ontouchend="stopTwistRotation();" class="cross-button right"><i class="fas fa-caret-right"></i></button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <style>
       /* カメライメージコンテナのスタイル */
        .camera-image-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cross-button {
            background-color: #00bcd4;
            color: whitesmoke;
            opacity: 0.75;
            border: none;
            padding: 20px 15px;
            cursor: pointer;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
        }

        .cross-button.left {
            left: 25%; /* 画像の左側からの位置を調整 */
        }

        .cross-button.right {
            right: 25%; /* 画像の右側からの位置を調整 */
        }

        img {
            max-width: 100%;
            max-height: 100%;
        }
    </style>

    <!--created by zenoh-->
    <!-- <div class="w3-card-4 w3-margin-bottom">
        <header class="w3-bar w3-cyan" onclick="document.getElementById('Drive').classList.toggle('w3-hide');">
            <h5 id="drive_label" class="w3-bar-item" style="margin: 0; color: white;">Drive</h5>
            <h5 class="w3-bar-item w3-right" style="margin: 0;"><i class='fa fa-gamepad' style='color: white;'></i></h5>
        </header>
        <div id="Drive" class="w3-container w3-padding">
            <div class="w3-auto" style="display: grid; width:12em; height:9em; ">
                <button onmousedown="pubTwist(1.0, 0.0);" onmouseup="pubTwist(0.0, 0.0);"
                    ontouchstart="pubTwist(1.0, 0.0);" ontouchend="pubTwist(0.0, 0.0);"
                    style='font-size:2em; grid-column: 2; grid-row: 1;'>
                    <i class='fas fa-caret-up'></i>
                </button>
                <button onmousedown="pubTwist(0.0, 1.0);" onmouseup="pubTwist(0.0, 0.0);"
                    ontouchstart="pubTwist(0.0, 1.0);" ontouchend="pubTwist(0.0, 0.0);"
                    style='font-size:2em; grid-column: 1; grid-row: 2;'>
                    <i class='fas fa-caret-left'></i>
                </button>
                <button onmousedown="pubTwist(-1.0, 0.0);" onmouseup="pubTwist(0.0, 0.0);"
                    ontouchstart="pubTwist(-1.0, 0.0);" ontouchend="pubTwist(0.0, 0.0);"
                    style='font-size:2em; grid-column: 2; grid-row: 2;'>
                    <i class='fas fa-caret-down'></i>
                </button>
                <button onmousedown="pubTwist(0.0, -1.0);" onmouseup="pubTwist(0.0, 0.0);"
                    ontouchstart="pubTwist(0.0, -1.0);" ontouchend="pubTwist(0.0, 0.0);"
                    style='font-size:2em; grid-column: 3; grid-row: 2;'>
                    <i class='fas fa-caret-right'></i>
                </button>
                <button onclick="pubTwist(0.0, 0.0);" style='font-size:2em; grid-column: 1 / 4; grid-row: 3;'>
                    STOP
                </button>
            </div>
            <br />
        </div>
    </div> -->

    <!-- created by chatgpt -->
    <div class="w3-card-4 w3-margin-bottom">
        <header class="w3-bar w3-cyan" onclick="document.getElementById('Drive').classList.toggle('w3-hide');">
            <h5 id="drive_label" class="w3-bar-item" style="margin: 0; color: white;">Drive</h5>
            <h5 class="w3-bar-item w3-right" style="margin: 0;"><i class='fa fa-gamepad' style='color: white;'></i></h5>
        </header>
        <div id="Drive" class="w3-container w3-padding">
            <div class="w3-auto" style="display: grid; width:12em; height:9em;">
                <button onmousedown="startTwist(1.0, 0.0);" onmouseup="stopTwist();"
                    ontouchstart="startTwist(1.0, 0.0);" ontouchend="stopTwist();"
                    style='font-size:2em; grid-column: 2; grid-row: 1; background-color:#83d3e2;'>
                    <i class='fas fa-caret-up' style="color:whitesmoke;"></i>
                </button>
                <button onmousedown="startTwist(0.0, 1.0);" onmouseup="stopTwist();"
                    ontouchstart="startTwist(0.0, 1.0);" ontouchend="stopTwist();"
                    style='font-size:2em; grid-column: 1; grid-row: 2; background-color:#83d3e2;'>
                    <i class='fas fa-caret-left' style="color:whitesmoke;"></i>
                </button>
                <button onmousedown="startTwist(-1.0, 0.0);" onmouseup="stopTwist();"
                    ontouchstart="startTwist(-1.0, 0.0);" ontouchend="stopTwist();"
                    style='font-size:2em; grid-column: 2; grid-row: 2; background-color:#83d3e2;'>
                    <i class='fas fa-caret-down' style="color:whitesmoke;"></i>
                </button>
                <button onmousedown="startTwist(0.0, -1.0);" onmouseup="stopTwist();"
                    ontouchstart="startTwist(0.0, -1.0);" ontouchend="stopTwist();"
                    style='font-size:2em; grid-column: 3; grid-row: 2; background-color:#83d3e2;'>
                    <i class='fas fa-caret-right' style="color:whitesmoke;"></i>
                </button>
                <button onclick="stopTwist();" style='font-size:2em; grid-column: 1 / 4; grid-row: 3; background-color:#83d3e2; color: whitesmoke;'>
                    STOP
                </button>
            </div>
            <br />
        </div>
    </div>

    <div class="w3-card-4 w3-margin-bottom">
        <header class="w3-bar w3-cyan" onclick="toggleJoystick();">
            <h5 id="joystick_label" class="w3-bar-item" style="margin: 0; color: white;">Joystick</h5>
            <h5 class="w3-bar-item w3-right" style="margin: 0;"><i class='fa fa-gamepad' style='color: white;'></i></h5>
        </header>
        <div id="JoystickContainer" class="w3-container w3-padding" style="width: 95%; height: 200px; position: relative;">
            <div id="Joystick" style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);"></div>
        </div>
        <br />
    </div>

    <!-- <div class="w3-card-4 w3-margin-bottom">
        <header class="w3-bar w3-cyan" onclick="document.getElementById('Lidar').classList.toggle('w3-hide');">
            <h5 id="lidar_label" class="w3-bar-item" style="margin: 0;">Lidar</h5>
            <h5 class="w3-bar-item w3-right" style="margin: 0;"><i class='fa fa-line-chart'></i></h5>
        </header>
        <div id="Lidar" class="w3-container w3-padding w3-hide" style="width: 95%; height: 300px;">
            <canvas id="Lidar-canvas" width="300" height="300"></canvas>
        </div>
        <br />
    </div> -->

    <div class="w3-card-4 w3-margin-bottom">
        <header class="w3-bar w3-cyan" onclick="document.getElementById('Logs').classList.toggle('w3-hide');">
            <h5 id="logs_label" class="w3-bar-item" style="margin: 0; color: white;">Logs</h5>
            <h5 class="w3-bar-item w3-right" style="margin: 0;"><i class='fa fa-envelope' style='color: white;'></i></h5>
        </header>
        <div id="Logs" class="w3-container w3-padding">
            <div style="overflow:auto; height:200px; border:1px solid black;" id="rosout_logs"></div>
        </div>
    </div>

    <div class="w3-card-4 w3-margin-bottom">
        <header class="w3-bar w3-cyan" onclick="document.getElementById('Config').classList.toggle('w3-hide');">
            <h5 class="w3-bar-item" style="margin: 0; color: white;">Config</h5>
            <h5 class="w3-bar-item w3-right" style="margin: 0;"><i class='fa fa-gear' style='color: white;'></i></h5>
        </header>
        <form id="Config" class="w3-container w3-hide">
            <label for="linear_scale">Linear scale:</label>
            <input id="linear_scale" class="w3-input w3-border w3-padding-small" type="number" required
                value="0.1"><br />
            <label for="angular_scale">Angular scale:</label>
            <input id="angular_scale" class="w3-input w3-border w3-padding-small" type="number" required
                value="0.5"><br />
        </form>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bytebuffer@5.0.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/jscdr@0.0.1"></script>
    <!-- tuika -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.7.3/nipplejs.js"></script>
    <script>
        // ROS2 topic names
        const TOPIC_LIDAR = "rt/scan";
        const TOPIC_BATTERY = "rt/battery_state";
        const TOPIC_LOGS = "rt/rosout";

        // MQTT topic name (for logging)
        const TOPIC_MQTT = "zigbee2mqtt/device/**"

        // Get "rest", "scope", "drive", and "lidar" from URL params, 
        // and set "rest_api", "scope_input", "drive_topic_input", and "lidar_topic_input" elements accordingly
        const urlParams = new URLSearchParams(window.location.search);
        const restParam = urlParams.get('rest');
        if (restParam != null && restParam.length > 0) {
            console.log("Set REST API from URL params: " + restParam);
            document.getElementById("rest_api").value = restParam;
        }
        const scopeParam = urlParams.get('scope');
        if (scopeParam != null && scopeParam.length > 0) {
            console.log("Set custom scope from URL params: " + scopeParam);
            document.getElementById("scope_input").value = scopeParam;
        }
        const driveParam = urlParams.get('drive');
        if (driveParam != null && driveParam.length > 0) {
            console.log("Set custom drive topin name from URL params: " + driveParam);
            document.getElementById("drive_topic_input").value = driveParam;
        }
        // const lidarParam = urlParams.get('lidar');
        // if (lidarParam != null && lidarParam.length > 0) {
        //     console.log("Set custom lidar topin name from URL params: " + lidarParam);
        //     document.getElementById("lidar_topic_input").value = lidarParam;
        // }

        // Add listener for input changes REST API, Scope, Drive topic, and LiDAR topic inputs
        document.getElementById("rest_api").addEventListener('change', (event) => {
            reloadPage(event.target.value, document.getElementById("scope_input").value, document.getElementById("drive_topic_input").value, document.getElementById("lidar_topic_input").value);
        });
        document.getElementById("scope_input").addEventListener('change', (event) => {
            reloadPage(document.getElementById("rest_api").value, event.target.value, document.getElementById("drive_topic_input").value, document.getElementById("lidar_topic_input").value);
        });
        document.getElementById("drive_topic_input").addEventListener('change', (event) => {
            reloadPage(document.getElementById("rest_api").value, document.getElementById("scope_input").value, event.target.value, document.getElementById("lidar_topic_input").value);
        });
        // document.getElementById("lidar_topic_input").addEventListener('change', (event) => {
        //     reloadPage(document.getElementById("rest_api").value, document.getElementById("scope_input").value, document.getElementById("drive_topic_input").value, event.target.value);
        // });
        function reloadPage(rest, s, drive, lidar) {
            window.location.search = 'rest=' + rest + "&scope=" + s + "&drive=" + drive + "&lidar=" + lidar;
        }

        // The REST API URL
        var rest_api = document.getElementById("rest_api").value;

        // The scope (used as a prefix for all Zenoh keys to publish and subscribe if not containing '*')
        var scope = document.getElementById("scope_input").value;
        if (scope.length > 0 && !scope.endsWith("/")) { scope += "/" }
        // If scope contains '*', default to "bot1" for subscription to avoid display conflicts of camera+lidar
        var sub_scope = scope.includes('*') ? "bot1/" : scope;

        // The drive topic name
        var drive_topic = document.getElementById("drive_topic_input").value;

        // The lidar topic name
        // var lidar_topic = document.getElementById("lidar_topic_input").value;

        /////////////////////////
        //  Twist publication  //
        /////////////////////////

        // Update Drive label
        let elem = document.getElementById("drive_label");
        elem.innerHTML = "Drive ( " + scope + drive_topic + " )"

        // Update Joystick label
        let elem2 = document.getElementById("joystick_label");
        elem2.innerHTML = "Joystick ( " + scope + drive_topic + " )"

        // HTTP client to call the REST API
        const Http = new XMLHttpRequest();

        // Timer for joystick made by chatgpt
        let twistInterval = null;

        let joystickVisible = false;
        function toggleJoystick() {
        let joystickContainer = document.getElementById('JoystickContainer');
            if (joystickVisible) {
                joystickContainer.classList.add('w3-hide');
            } else {
                joystickContainer.classList.remove('w3-hide');
            }
            joystickVisible = !joystickVisible;
        }

        function startTwist(linear, angular) {
            pubTwist(linear, angular, drive_topic);
            twistInterval = setInterval(function() {
                pubTwist(linear, angular, drive_topic);
            }, 100); // 100 milliseconds, adjust as needed
        }

        function stopTwist() {
            clearInterval(twistInterval);
            pubTwist(0.0, 0.0, drive_topic);
        }

        // Function to publish a Twist to cmd_vel topic
        function pubTwist(linear, angular, topicName) {
            // Get scales from HTML
            var linear_scale = document.getElementById("linear_scale").value
            var angular_scale = document.getElementById("angular_scale").value
            // let time = new Date().getTime(); // 修論のために作っています．システム時間取得です．

            // Create a Twist message
            var twist = new Twist(
                // new Vector3(linear * linear_scale, time, 0.0), // 修論のために作っています．システム時間取得です．
                new Vector3(linear * linear_scale, 0.0, 0.0),
                new Vector3(0.0, 0.0, angular * angular_scale));
            console.log(twist);
            // Since it's going to DDS, encode it using a jscdr.CDRWriter
            var writer = new jscdr.CDRWriter();
            twist.encode(writer);
            // The key expression for publication
            var key_expr = scope + topicName;
            console.log("Send " + topicName + " to " + rest_api + key_expr);

            // PUT it to zenoh via its REST API
            Http.open('PUT', rest_api + key_expr, true);
            Http.setRequestHeader('Content-Type', 'application/octet-stream');
            Http.send(writer.buf.buffer);
        }
        // Function to publish a Twist to cmd_vel topic with nipplejs
        function pubTwistJoy(linear, angular) {
            // Get scales from HTML
            var linear_scale = document.getElementById("linear_scale").value
            var angular_scale = document.getElementById("angular_scale").value

            pubTwist(linear / linear_scale, angular / angular_scale, drive_topic);
        }
        // Function to publish a Twist to rotation topic
        function pubTwistRotation(linear, angular) {
            // Get scales from HTML
            var linear_scale = document.getElementById("linear_scale").value
            var angular_scale = document.getElementById("angular_scale").value

            pubTwist(linear / linear_scale, angular / angular_scale, "rt/rotation");
        }

        function startTwistRotation(linear, angular) {
            var linear_scale = document.getElementById("linear_scale").value
            var angular_scale = document.getElementById("angular_scale").value
            pubTwist(linear / linear_scale, angular / angular_scale, "rt/rotation");
            twistInterval = setInterval(function() {
                pubTwist(linear / linear_scale, angular / angular_scale, "rt/rotation");
            }, 100); // 100 milliseconds, adjust as needed
        }

        function stopTwistRotation() {
            clearInterval(twistInterval);
            pubTwist(0.0, 0.0, "rt/rotation");
        }

        // create joystick instance
        createJoystick = function () {
            var options = {
                zone: document.getElementById('Joystick'),
                threshold: 0.1,
                position: { left: 70 + '%', top: 80 + '%'},
                mode: 'static',
                size: 150,
                color: '#00bcd4',
            };
            let manager = nipplejs.create(options);

            let linear_speed = 0;
            let angular_speed = 0;

            manager.on('start', function (event, nipple) {
                timer = setInterval(function () {
                    pubTwistJoy(linear_speed, angular_speed, drive_topic);
                }, 25);
            });

            manager.on('move', function (event, nipple) {
                max_linear = 1.5; // m/s
                max_angular = 1.0; // rad/s
                max_distance = 75.0; // pixels;
                linear_speed = Math.sin(nipple.angle.radian) * max_linear * nipple.distance/max_distance;
                angular_speed = -Math.cos(nipple.angle.radian) * max_angular * nipple.distance/max_distance;
            });

            manager.on('end', function () {
                if (timer) {
                    clearInterval(timer);
                }
                self.pubTwistJoy(0, 0, drive_topic);
            });
        }   
        document.addEventListener('DOMContentLoaded', function() {
            createJoystick();
        });

        function updateDualshockButton() {
            let angular_speed = 0.0;
            let gamepad = navigator.getGamepads();
            let buttons = gamepad[0].buttons;

            if (buttons[6].pressed) {
                angular_speed = 1.5;
            } else if (buttons[7].pressed) {
                angular_speed = -1.5;
            } else {
                angular_speed = 0.0;
            }
            pubTwistRotation(0.0, angular_speed);
        }

        function updateDualshockJoystick() {
            // default speed settings
            let linear_speed = 0.0;
            let angular_speed = 0.0;
            let max_linear = 2.0; // m/s
            let max_angular = 1.5; // rad/s
            let gamepad = navigator.getGamepads();
            let axes = gamepad[0].axes;

            // let j;
            // let n = axes.length;
            // for(j=0; j < n; j++) {

            //     // 軸の入力強度
            //     var axis = axes[j];
            //     console.log(j + ": " + axis);
            // }
            if (axes[1] > 0) {
                linear_speed = -max_linear * axes[1]; // backward
            } else if (axes[1] < 0) {
                linear_speed = -max_linear * axes[1]; // forward
            } else {
                linear_speed = 0.0; // stop
            }

            if (axes[2] > 0) {
                angular_speed = -max_angular * axes[2]; // left
            } else if (axes[2] < 0) {
                angular_speed = -max_angular * axes[2]; // right
            } else {
                angular_speed = 0.0; // stop
            }
            pubTwistJoy(linear_speed, angular_speed, drive_topic);
        }
        window.addEventListener("gamepadconnected", function() {
            console.log("Gamepad connected");
            setInterval("updateDualshockJoystick()", 100); // Execute updateDualshockJoystick() every 100ms
            // setInterval("updateDualshockButton()", 100); // Execute updateDualshockButton() every 100ms
        });

        // callback on keyboard's down key event
        function onkeydown(e) {
            e = e || window.event;
            console.log("KeyPressed: " + e);
            if (e.keyCode == '38') {
                // up arrow
                pubTwist(1.0, 0.0, drive_topic);
            }
            else if (e.keyCode == '40') {
                // down arrow
                pubTwist(-1.0, 0.0, drive_topic);
            }
            else if (e.keyCode == '37') {
                // left arrow
                pubTwist(0.0, 1.0, drive_topic);
            }
            else if (e.keyCode == '39') {
                // right arrow
                pubTwist(0.0, -1.0, drive_topic);
            }
            else if (e.keyCode == '32') {
                // spacebar
                pubTwist(0.0, 0.0, drive_topic);
            }
        }
        // register callback on key down
        document.onkeydown = onkeydown;

        // callback on keyboard's up key event
        function onkeyup(e) {
            // if key pressed was an arrow, send a Twist(0,0) to stop the robot
            if (e.keyCode == '37' || e.keyCode == '38' || e.keyCode == '39' || e.keyCode == '40')
                pubTwist(0.0, 0.0, drive_topic);
        }
        // register callback on key up
        document.onkeyup = onkeyup;

        // function changeBockgroundColor() {
        //     let elem = document.getElementById("drive_label");
        //     elem.style.backgroundColor = "red";
        // }

        ////////////////////////////
        //  Battery subscription  //
        ////////////////////////////
        var battery_source = null;

        // Test if Server-Source Event is supported
        if (typeof (EventSource) !== "undefined") {
            // the key expression to subscribe
            var key_expr = sub_scope + TOPIC_BATTERY;

            // Create EventSource for subscription to key_expr
            console.log("Subscribe to EventSource: " + rest_api + key_expr);
            battery_source = new EventSource(rest_api + key_expr);
            battery_source.addEventListener("PUT", function (e) {
                console.log("Received sample: " + e.data);
                // The zenoh REST API sends JSON objects
                // that includes "key", "value", "encoding" and "time" (same than a result to GET)
                let sample = JSON.parse(e.data)
                // The payload buffer is in "value" field, encoded as base64.
                // Since it's comming from DDS, we decode it using a jscdr.CDRReader.
                let reader = new jscdr.CDRReader(dcodeIO.ByteBuffer.fromBase64(sample.value));
                // Decode the buffer as a BatteryState message
                let battery = BatteryState.decode(reader);
                // Set it to "battery" HTML element
                let elem = document.getElementById("battery_label");
                elem.innerHTML = "Battery: " + Math.round(battery.percentage) + " %";
            }, false);

        } else {
            document.getElementById("rosout_logs").innerHTML = "Sorry, your browser does not support server-sent events...";
        }

        //////////////////////////////////////////////////////////////////
        //  Camera subscription (as motion-JPEG via WebService plugin)  //
        //////////////////////////////////////////////////////////////////

        // If your robot has a camera and zcapture installed (from zenoh-demos/computer-vision/zcam/):
        // the zcapture must be started with "-k <scope>/camera", and the zenoh router must have the WebServer plugin running
        function updateCameraDisplay(cameraNumber, subScope) {
            const cameraLabel = document.getElementById("camera_label" + cameraNumber);
            const cameraImg = document.getElementById("camera_img" + cameraNumber);

            if (cameraImg != null) {
                // Update Camera label
                cameraLabel.innerHTML = "Camera " + cameraNumber + " ( " + subScope + "camera )";

                // Set "camera_img" element's src to the same URL host, but with port 8080 (WebServer plugin)
                // and with path: "<scope>/camera?_method=SUB"
                const imgURL = rest_api.replace(":8000", ":8080") + subScope + "camera?_method=SUB";
                console.log("Set camera_img" + cameraNumber + " src to: " + imgURL);
                cameraImg.src = imgURL;
            }
        }

        updateCameraDisplay(1, sub_scope);
        updateCameraDisplay(2, sub_scope.slice(0, -1) + "1/");

        ///////////////////////////////
        //    Lidar subscription     //
        ///////////////////////////////
        // var lidar_source = null;

        // // Test if Server-Source Event is supported
        // if (typeof (EventSource) !== "undefined") {
        //     // the key expression to subscribe
        //     var key_expr = sub_scope + lidar_topic;

        //     // update Lidar label
        //     let elem = document.getElementById("lidar_label");
        //     elem.innerHTML = "LiDAR ( " + key_expr + " )";

        //     // Get canvas context and get its dimensions
        //     const canvas = document.getElementById('Lidar-canvas');
        //     const ctx = canvas.getContext('2d');
        //     const width = canvas.width;
        //     const height = canvas.height;

        //     // Clear canvas
        //     ctx.clearRect(0, 0, width, height);

        //     // Create EventSource for subscription to key_expr
        //     console.log("Subscribe to EventSource: " + rest_api + key_expr);
        //     console.log("OLD Lidar EventSource " + lidar_source);
        //     lidar_source = new EventSource(rest_api + key_expr);
        //     lidar_source.onmessage = function (e) { console.log("!!!!! ERR: " + e) };
        //     console.log("NEW LiDAR EventSource " + lidar_source.url);
        //     lidar_source.addEventListener("PUT", function (e) {
        //         let sample = JSON.parse(e.data);
        //         // The payload buffer is in "value" field, encoded as base64.
        //         // Since it's comming from DDS, we decode it using a jscdr.CDRReader.
        //         let reader = new jscdr.CDRReader(dcodeIO.ByteBuffer.fromBase64(sample.value));
        //         // Decode the buffer as an LaserScan message
        //         let scan = LaserScan.decode(reader);

        //         // Force range_max to 3.5 for consistency between robots
        //         max_range_displayed = 3.5
        //         //max_range_displayed = scan.range_max

        //         // Convert to [x,y, isInRange] points, where:
        //         //  - if isInRange==true then {x,y} are the relative coordinates computed from {angle,range}
        //         //  - if isInRange==false then the range was out of range_min/range_max and {x,y} are the relative
        //         //    coordinate of {angle,LIMIT} where LIMIT is range_max or range_min (the closest bound).
        //         let angle = -3.1415927410125732;
        //         let scale = Math.min(canvas.width, canvas.height) / 2 / max_range_displayed;
        //         let points = [];
        //         for (const range of scan.ranges) {
        //             var r = range;
        //             var isInRange = true;
        //             if (range > scan.range_max) {
        //                 r = scan.range_max;
        //                 isInRange = false;
        //             } else if (range < scan.range_min) {
        //                 r = scan.range_min;
        //                 isInRange = false;
        //             }

        //             const x = r * scale * Math.sin(angle);
        //             const y = r * scale * Math.cos(angle);
        //             points.push([x, y, isInRange]);
        //             angle += scan.angle_increment;
        //         }

        //         // Clear canvas
        //         ctx.clearRect(0, 0, width, height);

        //         // Draw rays
        //         ctx.lineWidth = 2;
        //         for (const [x, y, isInRange] of points) {
        //             ctx_x = x + width / 2;
        //             ctx_y = y + height / 2;
        //             ctx.beginPath();
        //             if (isInRange) {
        //                 ctx.strokeStyle = 'LightGray';
        //             } else {
        //                 ctx.strokeStyle = 'Gainsboro';
        //             }
        //             ctx.moveTo(width / 2, height / 2);
        //             ctx.lineTo(ctx_x, ctx_y);
        //             ctx.stroke();
        //         }

        //         // Draw points
        //         ctx.fillStyle = 'red';
        //         for (const [x, y, isInRange] of points) {
        //             ctx_x = x + width / 2;
        //             ctx_y = y + height / 2;
        //             if (isInRange) {
        //                 ctx.fillRect(ctx_x, ctx_y, 1, 1);
        //             }
        //         }

        //         // Draw axis lines
        //         ctx.beginPath();
        //         ctx.strokeStyle = 'DimGray';
        //         ctx.lineWidth = 1;
        //         ctx.moveTo(0, height / 2);
        //         ctx.lineTo(width, height / 2);
        //         ctx.moveTo(width / 2, 0);
        //         ctx.lineTo(width / 2, height);
        //         ctx.stroke();

        //     }, false);
        // } else {
        //     document.document.getElementById("Lidar").innerHTML = "Sorry, your browser does not support server-sent events...";
        // }

        //////////////////////////////////
        //    Logs subscription (ROS2)  //
        //////////////////////////////////
        let ros2_logs_source = null;

        // Test if Server-Source Event is supported
        if (typeof (EventSource) !== "undefined") {
            // the key expression to subscribe
            var key_expr = sub_scope + TOPIC_LOGS;

            // update Lidar label
            let elem = document.getElementById("logs_label");
            elem.innerHTML = "Logs ( " + key_expr + " + " + TOPIC_MQTT + " )";

            // Create EventSource for subscription to key_expr
            console.log("Subscribe to EventSource: " + rest_api + key_expr);
            ros2_logs_source = new EventSource(rest_api + key_expr);
            ros2_logs_source.addEventListener("PUT", function (e) {
                console.log("Received sample: " + e.data);
                // The zenoh REST API sends JSON objects
                // that includes "key", "value", "encoding" and "time" (same than a result to GET)
                let sample = JSON.parse(e.data)
                // The payload buffer is in "value" field, encoded as base64.
                // Since it's comming from DDS, we decode it using a jscdr.CDRReader.
                let reader = new jscdr.CDRReader(dcodeIO.ByteBuffer.fromBase64(sample.value));
                // Decode the buffer as a Log message
                let log = Log.decode(reader);
                // Add it to "rosout_logs" HTML element
                let elem = document.getElementById("rosout_logs");
                elem.innerHTML += "ROS2: [" + log.time.sec + "." + log.time.nsec + "] [" + log.name + "]: " + log.msg + "<br>";
                // Auto-scroll to the bottom
                elem.scrollTop = elem.scrollHeight;
            }, false);

        } else {
            document.getElementById("rosout_logs").innerHTML = "Sorry, your browser does not support server-sent events...";
        }

        //////////////////////////////////
        //    Logs subscription (MQTT)  //
        //////////////////////////////////
        let mqtt_logs_source = null;

        // Test if Server-Source Event is supported
        if (typeof (EventSource) !== "undefined") {
            // the key expression to subscribe (no scope used by MQTT bridge as only 1)
            var key_expr = TOPIC_MQTT;

            console.log("Subscribe to EventSource: " + rest_api + key_expr);
            ros2_logs_source = new EventSource(rest_api + key_expr);
            ros2_logs_source.addEventListener("PUT", function (e) {
                console.log("Received sample: " + e.data);
                // The zenoh REST API sends JSON objects
                // that includes "key", "value", "encoding" and "time" (same than a result to GET)
                let sample = JSON.parse(e.data)
                // Add it to "rosout_logs" HTML element
                let elem = document.getElementById("rosout_logs");
                elem.innerHTML += "MQTT: on " + sample.key + " : " + JSON.stringify(sample.value) + "<br>";
                // Auto-scroll to the bottom
                elem.scrollTop = elem.scrollHeight;
            }, false);

        } else {
            document.getElementById("rosout_logs").innerHTML = "Sorry, your browser does not support server-sent events...";
        }

        /////////////////////////////////////////////////////////////
        // ROS2 Types declaration with CDR encode/decode functions //
        /////////////////////////////////////////////////////////////

        // ROS2 Time type
        class Time {
            constructor(sec, nsec) {
                this.sec = sec;
                this.nsec = nsec;
            }

            static decode(cdrReader) {
                let sec = cdrReader.readInt32();
                let nsec = cdrReader.readUint32();
                return new Time(sec, nsec);
            }
        }

        // ROS2 Log type (received in 'rosout' topic)
        class Log {
            constructor(time, level, name, msg, file, fn, line) {
                this.time = time;
                this.level = level;
                this.name = name;
                this.msg = msg;
                this.file = file;
                this.fn = fn;
                this.line = line;
            }

            static decode(cdrReader) {
                let time = Time.decode(cdrReader);
                let level = cdrReader.readByte();
                let name = cdrReader.readString();
                let msg = cdrReader.readString();
                let file = cdrReader.readString();
                let fn = cdrReader.readString();
                let line = cdrReader.readUint32();
                return new Log(time, level, name, msg, file, fn, line);
            }
        }

        // ROS2 Vector3 type
        class Vector3 {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            encode(cdrWriter) {
                cdrWriter.writeFloat64(this.x);
                cdrWriter.writeFloat64(this.y);
                cdrWriter.writeFloat64(this.z);
            }

            static decode(cdrReader) {
                let x = cdrReader.readFloat64();
                let y = cdrReader.readFloat64();
                let z = cdrReader.readFloat64();
                return new Vector3(x, y, z);
            }
        }

        // ROS2 Quaternion type
        class Quaternion {
            constructor(x, y, z, w) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }

            static decode(cdrReader) {
                let x = cdrReader.readFloat64();
                let y = cdrReader.readFloat64();
                let z = cdrReader.readFloat64();
                let w = cdrReader.readFloat64();
                return new Quaternion(x, y, z, w);
            }
        }

        // ROS2 Twist type (published in 'cmd_vel' topic)
        class Twist {
            constructor(linear, angular) {
                this.linear = linear;
                this.angular = angular;
            }

            encode(cdrWriter) {
                this.linear.encode(cdrWriter);
                this.angular.encode(cdrWriter);
            }
        }

        // ROS2 Header type
        class Header {
            constructor(time, frame_id) {
                this.time = time;
                this.frame_id = frame_id;
            }

            static decode(cdrReader) {
                let time = Time.decode(cdrReader);
                let frame_id = cdrReader.readString();
            }
        }


        // ROS2 BatteryState type (received in 'battery_state' topic)
        // Warning: not complete, since we only need to decode up-to 'percentage'
        // class BatteryState {
        //     constructor(header, voltage, temperature, current, charge, capacity, design_capacity, percentage) {
        //         this.header = header;
        //         this.voltage = voltage;
        //         this.temperature = temperature;
        //         this.current = current;
        //         this.charge = charge;
        //         this.capacity = capacity;
        //         this.design_capacity = design_capacity;
        //         this.percentage = percentage;
        //     }

        //     static decode(cdrReader) {
        //         let header = Header.decode(cdrReader);
        //         let voltage = cdrReader.readFloat32();
        //         let temperature = cdrReader.readFloat32();
        //         let current = cdrReader.readFloat32();
        //         let charge = cdrReader.readFloat32();
        //         let capacity = cdrReader.readFloat32();
        //         let design_capacity = cdrReader.readFloat32();
        //         let percentage = cdrReader.readFloat32();
        //         return new BatteryState(header, voltage, temperature, current, charge, capacity, design_capacity, percentage);
        //     }
        // }

        // ROS2 LaserScan type (received in 'scan' topic)
        class LaserScan {
            constructor(header, angle_min, angle_max, angle_increment, time_increment, scan_time, range_min, range_max, ranges, intensities) {
                this.header = header;
                this.angle_min = angle_min;
                this.angle_max = angle_max;
                this.angle_increment = angle_increment;
                this.time_increment = time_increment;
                this.scan_time = scan_time;
                this.range_min = range_min;
                this.range_max = range_max;
                this.ranges = ranges;
                this.intensities = intensities;
            }

            static decode(cdrReader) {
                let header = Header.decode(cdrReader);
                let angle_min = cdrReader.readFloat32();
                let angle_max = cdrReader.readFloat32();
                let angle_increment = cdrReader.readFloat32();
                let time_increment = cdrReader.readFloat32();
                let scan_time = cdrReader.readFloat32();
                let range_min = cdrReader.readFloat32();
                let range_max = cdrReader.readFloat32();

                let ranges_length = cdrReader.readInt32()
                let ranges = [];
                for (const x of Array(ranges_length).keys()) {
                    ranges.push(cdrReader.readFloat32())
                }

                let intensities_length = cdrReader.readInt32()
                let intensities = [];
                for (const x of Array(intensities_length).keys()) {
                    intensities.push(cdrReader.readFloat32())
                }
                return new LaserScan(header, angle_min, angle_max, angle_increment, time_increment, scan_time, range_min, range_max, ranges, intensities);
            }
        }

    </script>

    <script type="text/javascript">
    </script>

</body>

</html>
